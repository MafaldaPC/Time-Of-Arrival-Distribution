import numpy as np
import scipy as sp
import matplotlib.pyplot as plt

class ArrivalTime():
    """ Compute arrival time proposals for a superposition of Gaussian wave packets, with detector located at x = 0."""
    def __init__(self, train):
        """ Initialize superposition of Gaussian packets.
        Parameters:
        packets : class
            Superposition generated by GaussianTrain().
        """
        self.condwavefunc = train.condsuperposition
        self.wavefunc = train.superposition # Superposition
        self.toa = {} # Arrival time distributions

    def quantumclock(self, tVar, tLim):
        """ Compute quantum clock (Page-Wootters) proposal.
        Parameters:
        tVar : float or array-like
            Time variable.
        tLim : tuple or array-like
            Temporal domain.
        """
        def toa(t):
            """ Arrival time distribution. 
            Parameters:
            t : float or array-like
                Time variable.
            """
            return np.abs(self.wavefunc(t, 0))**2
            
        norm, _ = sp.integrate.quad(toa, tLim[0], tLim[1])
        self.toa['Quantum clock'] = toa(tVar)/norm

  
    def click(self, tVar, xVar, xDtc, numclick): 
        """ Compute click proposal.
        Parameters:
        tVar : float or array-like
            Time variable limited to the instants where the detector clicks.
        tLim : tuple or array-like
            Temporal domain.
        xLim: tuple or array-like
            Spacial Domain.
        xDtc : tuple or array-like
            Spacial domain of the detector.
        f : int
            Number of Clicks under consideration.
        click : float
            Time spent between two consecutive clicks.
        numclick : int
            Number of clicks possible in the Temporal domain.
        """ 
        dt = tVar[1]-tVar[0]
        click = numclick * dt
        def toa(t):
            """Conditioned arrival time distribution. 
            Parameters:
            t : float or array-like
                Time variable.
            """
            return self.condwavefunc(t, xVar, xDtc, click, numclick)

        wave = toa(tVar[0])
        norm = np.sum(wave)*click
        #i=1
        #norm = 0
        #while click*i<tLim[1]:
        #    norms, _ = sp.integrate.quad(toa, tLim[0]+click*(i-1), tLim[0]+click*i)
        #    norm += norms
        #    i=i+1
        self.toa['Click Approach'] = wave/norm
        

    def quantumflux(self, tVar, tLim):
        """ Compute quantum flux proposal.
        Parameters:
        tVar : float or array-like
            Time variable.
        tLim : tuple or array-like
            Temporal domain.
        """
        deriv = np.zeros_like(tVar, dtype = complex)
        def toa(tVar):
            """ Arrival time distribution. 
            Parameters:
            tVar : float or array-like
                Time variable.
            """
            scalar = np.isscalar(tVar) # Check scalar
            tArr = np.atleast_1d(tVar) # Ensure array
            for idx, t in enumerate(tArr):
                real = lambda x: np.real(self.wavefunc(t, x))
                dreal = sp.differentiate.derivative(real, 0.0).df
                imag = lambda x: np.imag(self.wavefunc(t, x))
                dimag = sp.differentiate.derivative(imag, 0.0).df
                deriv[idx] = dreal + 1j*dimag
            result =  np.imag(np.conj(self.wavefunc(tVar, 0))*deriv)
            if scalar: # Quad compatibility
                return float(result[0])
            return result

        norm, _ = sp.integrate.quad(toa, tLim[0], tLim[1])
        self.toa['Quantum flux'] = toa(tVar)/norm

    def visualize(self, numPoints, tLim, xLim, xDtc):
        """ Visualize wave function and compare arrival time proposals.
        Parameters:
        numPoints : int
            Number of points in each dimension (x and t).
        tLim : tuple or array-like
            Temporal domain.
        xLim : tuple or array-like
            Spatial domain.
        xDtc : float
            Detector position for density (xDtc = 0 for arrival time distributions)
        """
        t = np.linspace(tLim[0], tLim[1], numPoints)
        x = np.linspace(xLim[0], xLim[1], numPoints)
        T, X = np.meshgrid(t, x)

        density = np.abs(self.wavefunc(T, X))**2
        densityDtc = np.abs(self.wavefunc(t, xDtc))**2
        self.quantumclock(t,tLim)


        plt.rcParams.update({'font.size': 12})
        plt.rcParams["font.family"] = "serif"
        lines = ['-','--','-','-.']
        markers = ['None', 'None', '^', 'v']
        colors = np.array(['tab:blue', 'tab:orange', 'tab:green', 'tab:red',\
                      'tab:purple','tab:brown'])
        fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(18, 5), dpi = 400,\
                                            constrained_layout = True) # Figure
        
        pcm = ax1.pcolormesh(T, X, density, shading='auto', cmap='viridis')
        fig.colorbar(pcm, ax = ax1, label="Density")
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Position")
        ax1.title.set_text("Wave packets density")
        ax2.plot(t, densityDtc, color = 'tab:blue', marker = 'None', linestyle = '-',\
                 markersize = 1, linewidth = 1)
        ax2.set_xlabel("Time")
        ax2.title.set_text(f"Density at x = {xDtc}")
        for idx, key in enumerate(self.toa):
            ax3.plot(t, self.toa[key], color = colors[idx], marker = markers[idx], linestyle = lines[idx],\
                     markersize = 1, linewidth = 1, label = key)
        ax3.set_xlabel("Time")
        ax3.set_ylabel("Probability")
        ax3.title.set_text("Arrival time distributions")
        ax3.legend(loc = 'upper right')
        
        plt.show()


    def visualizec(self, numPoints, tLim, xLim, xDtc, f, nclick):
        """ Visualize wave function and compare arrival time proposals with click approach.
        Parameters:
        numPoints : int
            Number of points in each dimension (x and t).
        tLim : tuple or array-like
            Temporal domain.
        xLim : tuple or array-like
            Spatial domain.
        xDtc : tuple or array-like
            Detector position for density.
        f : int
          Number of Clicks under consideration.
        nclick : int
          Number of clicks possible in the Temporal domain.
        """
        
        t = np.linspace(tLim[0], tLim[1], numPoints)
        #tcond = np.linspace(tLim[0], tLim[1], int(numPoints/nclick))
        x = np.linspace(xLim[0], xLim[1], numPoints)
        T, X = np.meshgrid(t, x)
        density = np.abs(self.wavefunc(T, X))**2
        #densitys = np.abs(self.condwavefunc(t, xDtc, f, t[1]-t[0]))**2 
        densityDtc = np.abs(self.wavefunc(t, xDtc[0]))**2
        self.quantumclock(t,tLim)
        self.click(t, x, xDtc, nclick)
        taux = []
        for i in range(numPoints): #Time domain of the Click Approach
            if i % nclick == 0:
                taux.append(t[i])


        plt.rcParams.update({'font.size': 12})
        plt.rcParams["font.family"] = "serif"
        lines = ['-','--','-','-.']
        markers = ['None', 'None', '^', 'v']
        colors = np.array(['tab:blue', 'tab:orange', 'tab:green', 'tab:red',\
                      'tab:purple','tab:brown'])
        fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(18, 5), dpi = 400,\
                                            constrained_layout = True) # Figure
        
        pcm = ax1.pcolormesh(T, X, density, shading='auto', cmap='viridis')
        fig.colorbar(pcm, ax = ax1, label="Density")
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Position")
        ax1.title.set_text("Wave packets density")
        ax2.plot(t, densityDtc, color = 'tab:blue', marker = 'None', linestyle = '-',\
                 markersize = 1, linewidth = 1)
        ax2.set_xlabel("Time")
        ax2.title.set_text(f"Density at x = {xDtc}")
        
        for idx, key in enumerate(self.toa):
            if key == 'Click Approach':
                ax3.plot(taux, self.toa[key], color = colors[idx], marker = markers[idx], linestyle = lines[idx],\
                     markersize = 1, linewidth = 1, label = key)
            else:
                ax3.plot(t, self.toa[key], color = colors[idx], marker = markers[idx], linestyle = lines[idx],\
                     markersize = 1, linewidth = 1, label = key)
        ax3.set_xlabel("Time")
        ax3.set_ylabel("Probability")
        ax3.title.set_text("Arrival time distributions")
        ax3.legend(loc = 'upper center', bbox_to_anchor=(0.5, -0.05), fancybox=True, shadow=True, ncol=5)

        
        plt.show()
